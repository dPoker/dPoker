# The MIT License (MIT)
# Copyright Â© 2023 Yuma Rao

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial portions of
# the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
# THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

"""Aceguard validator entrypoint wired into the base Bittensor neuron."""
# neuron/validator.py

from __future__ import annotations

import os
import random
import time
from typing import Optional, List, Dict, Any

import bittensor as bt
from dotenv import load_dotenv

from Aceguard import __version__
from Aceguard.base.validator import BaseValidatorNeuron
from Aceguard.utils.config import config
from Aceguard.core.hand_json import from_standard_json
from Aceguard.core.models import LabeledHandBatch
from Aceguard.validator.forward import forward as forward_cycle
from hands_generator.data_generator import generate_dataset_array

load_dotenv()
os.makedirs("./logs", exist_ok=True)
bt.logging.set_trace()
bt.logging(debug=True, trace=False, logging_dir="./logs", record_log=True)


class GeneratedDatasetProvider:
    """
    Local provider that sources hands from the in-memory dataset generated by
    hands_generator.data_generator.generate_dataset_array(include_labels=True).
    """

    def __init__(
        self,
        labeled_chunks: List[Dict[str, Any]],
        *,
        shuffle: bool = True,
        loop: bool = True,
    ) -> None:
        self.shuffle = shuffle
        self.loop = loop
        self._data = list(labeled_chunks)
        if self.shuffle:
            random.shuffle(self._data)
        self._idx = 0

    def fetch_hand_batch(
        self,
        *,
        limit: int = 10,
        include_integrity: bool = True,
    ) -> List[LabeledHandBatch]:
        if not self._data:
            return []

        batches: List[LabeledHandBatch] = []
        for _ in range(limit):
            if self._idx >= len(self._data):
                if not self.loop:
                    break
                self._idx = 0
                if self.shuffle:
                    random.shuffle(self._data)

            entry = self._data[self._idx]
            self._idx += 1

            hands_raw = entry.get("hands", [])
            is_bot = bool(entry.get("is_bot", False))
            hands = [from_standard_json(hand) for hand in hands_raw]
            batches.append(LabeledHandBatch(hands=hands, is_human=not is_bot))

        return batches


class Validator(BaseValidatorNeuron):
    """Aceguard validator neuron wired into the BaseValidator scaffold."""

    def __init__(self):
        cfg = config(Validator)
        super().__init__(config=cfg)
        bt.logging.info(f"ðŸš€ Aceguard Validator v{__version__} started")

        self.forward_count = 0
        self.settings = cfg
        
        local_total_hands = int(os.getenv("ACEGUARD_LOCAL_TOTAL_HANDS", "100"))
        local_human_ratio = float(os.getenv("ACEGUARD_LOCAL_HUMAN_RATIO", "0.5"))

        bt.logging.info("ðŸ“ Using LOCAL generated data")
        labeled_chunks = generate_dataset_array(
            include_labels=True,
        )
        self.provider = GeneratedDatasetProvider(labeled_chunks, shuffle=True, loop=True)
        self.poll_interval = self.settings.poll_interval_seconds
        self.prediction_buffer = {}
        self.label_buffer = {}

    def resolve_uid(self, hotkey: str) -> Optional[int]:
        try:
            return self.metagraph.hotkeys.index(hotkey)
        except ValueError:
            return None

    async def forward(self, synapse=None):  # type: ignore[override]
        return await forward_cycle(self)


if __name__ == "__main__":  # pragma: no cover - manual execution
    with Validator() as validator:
        while True:
            bt.logging.info(f"Validator running... {time.time()}")
            time.sleep(100)
