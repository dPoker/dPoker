# The MIT License (MIT)
# Copyright Â© 2023 Yuma Rao

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial portions of
# the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
# THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

"""poker44 validator entrypoint wired into the base Bittensor neuron."""
# neuron/validator.py

from __future__ import annotations

import os
import random
import threading
import time
from typing import Optional, List, Dict, Any

import bittensor as bt
from dotenv import load_dotenv
import requests

from poker44 import __version__
from poker44.base.validator import BaseValidatorNeuron
from poker44.utils.config import config
from poker44.core.hand_json import from_standard_json
from poker44.core.models import LabeledHandBatch
from poker44.validator.forward import forward as forward_cycle
from poker44.hands_generator.data_generator import generate_dataset_array
from poker44.p2p.directory_client import RoomDirectoryClient

load_dotenv()
os.makedirs("./logs", exist_ok=True)
bt.logging.set_trace()
bt.logging(debug=True, trace=False, logging_dir="./logs", record_log=True)


class GeneratedDatasetProvider:
    """
    Local provider that sources hands from the in-memory dataset generated by
    poker44.hands_generator.data_generator.generate_dataset_array(include_labels=True).
    """

    def __init__(
        self,
        labeled_chunks: List[Dict[str, Any]],
        *,
        shuffle: bool = True,
        loop: bool = True,
    ) -> None:
        self.shuffle = shuffle
        self.loop = loop
        self._data = list(labeled_chunks)
        if self.shuffle:
            random.shuffle(self._data)
        self._idx = 0

    def fetch_hand_batch(
        self,
        *,
        limit: int = 10,
        include_integrity: bool = True,
    ) -> List[LabeledHandBatch]:
        if not self._data:
            return []

        batches: List[LabeledHandBatch] = []
        for _ in range(limit):
            if self._idx >= len(self._data):
                if not self.loop:
                    break
                self._idx = 0
                if self.shuffle:
                    random.shuffle(self._data)

            entry = self._data[self._idx]
            self._idx += 1

            hands_raw = entry.get("hands", [])
            is_bot = bool(entry.get("is_bot", False))
            hands = [from_standard_json(hand) for hand in hands_raw]
            batches.append(LabeledHandBatch(hands=hands, is_human=not is_bot))

        return batches


class PlatformBackendProvider:
    """
    Provider that pulls *fresh* labeled batches from the local validator poker backend.

    The backend must expose:
      GET /internal/eval/next?limit=10&requireMixed=true
    with header:
      x-eval-secret: <shared secret>

    Response format:
      { "success": true, "data": { "batches": [ { "is_human": bool, "hands": [dict, ...] }, ... ] } }
    """

    def __init__(
        self,
        base_url: str,
        secret: str,
        *,
        require_mixed: bool = True,
        timeout_s: float = 5.0,
        autosimulate: bool = False,
        simulate_humans: int = 2,
        simulate_bots: int = 2,
        simulate_hands: int = 3,
        simulate_timeout_s: float = 30.0,
        min_simulate_interval_s: int = 15,
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.secret = secret
        self.require_mixed = require_mixed
        self.timeout_s = timeout_s
        self.autosimulate = autosimulate
        self.simulate_humans = int(simulate_humans)
        self.simulate_bots = int(simulate_bots)
        self.simulate_hands = int(simulate_hands)
        self.simulate_timeout_s = float(simulate_timeout_s)
        self.min_simulate_interval_s = int(min_simulate_interval_s)

        self._simulate_lock = threading.Lock()
        self._last_simulate_ts: int = 0

    def _fetch_next_raw_batches(self, *, limit: int) -> list[dict]:
        r = requests.get(
            f"{self.base_url}/internal/eval/next",
            params={
                "limit": int(limit),
                "requireMixed": "true" if self.require_mixed else "false",
            },
            headers={"x-eval-secret": self.secret},
            timeout=self.timeout_s,
        )
        r.raise_for_status()
        data = r.json()
        if not isinstance(data, dict) or not data.get("success"):
            return []
        payload = data.get("data", {}) or {}
        raw_batches = payload.get("batches", [])
        return raw_batches if isinstance(raw_batches, list) else []

    def _maybe_simulate(self) -> None:
        now = int(time.time())
        if now - self._last_simulate_ts < self.min_simulate_interval_s:
            return
        if not self._simulate_lock.acquire(blocking=False):
            return
        try:
            now = int(time.time())
            if now - self._last_simulate_ts < self.min_simulate_interval_s:
                return

            requests.post(
                f"{self.base_url}/internal/eval/simulate",
                headers={"x-eval-secret": self.secret, "content-type": "application/json"},
                json={
                    "humans": self.simulate_humans,
                    "bots": self.simulate_bots,
                    "hands": self.simulate_hands,
                },
                timeout=self.simulate_timeout_s,
            ).raise_for_status()
            self._last_simulate_ts = int(time.time())
        except Exception as e:
            bt.logging.warning(f"Platform provider simulate failed: {e}")
        finally:
            self._simulate_lock.release()

    def fetch_hand_batch(
        self,
        *,
        limit: int = 10,
        include_integrity: bool = True,  # kept for provider compatibility
    ) -> List[LabeledHandBatch]:
        if not self.secret:
            bt.logging.warning(
                "POKER44_INTERNAL_EVAL_SECRET not set; cannot use platform provider."
            )
            return []

        raw_batches: list[dict] = []
        try:
            raw_batches = self._fetch_next_raw_batches(limit=int(limit))
        except Exception as e:
            bt.logging.warning(f"Platform provider fetch failed: {e}")
            return []

        if not raw_batches and self.autosimulate:
            self._maybe_simulate()
            try:
                raw_batches = self._fetch_next_raw_batches(limit=int(limit))
            except Exception as e:
                bt.logging.warning(f"Platform provider re-fetch failed: {e}")
                raw_batches = []

        out: List[LabeledHandBatch] = []
        for b in raw_batches:
            try:
                is_human = bool(b.get("is_human", False))
                hands = b.get("hands", [])
                # Hands are already dict payloads (sanitized by the backend).
                out.append(LabeledHandBatch(hands=hands, is_human=is_human))
            except Exception:
                continue
        return out


class Validator(BaseValidatorNeuron):
    """poker44 validator neuron wired into the BaseValidator scaffold."""

    def __init__(self):
        cfg = config(Validator)
        super().__init__(config=cfg)
        bt.logging.info(f"ðŸš€ poker44 Validator v{__version__} started")

        self.forward_count = 0
        self.settings = cfg
        
        provider_mode = (os.getenv("POKER44_PROVIDER") or "local_generated").strip().lower()
        if provider_mode == "platform":
            bt.logging.info("ðŸ”Œ Using PLATFORM backend provider (fresh hands)")
            self.provider = PlatformBackendProvider(
                base_url=os.getenv("POKER44_PLATFORM_BACKEND_URL") or "http://localhost:3001",
                secret=os.getenv("POKER44_INTERNAL_EVAL_SECRET") or "",
                require_mixed=(os.getenv("POKER44_REQUIRE_MIXED") or "true").lower() != "false",
                timeout_s=float(os.getenv("POKER44_PLATFORM_TIMEOUT_S") or "5.0"),
                autosimulate=(os.getenv("POKER44_AUTOSIMULATE") or "false").lower() == "true",
                simulate_humans=int(os.getenv("POKER44_AUTOSIMULATE_HUMANS") or "2"),
                simulate_bots=int(os.getenv("POKER44_AUTOSIMULATE_BOTS") or "2"),
                simulate_hands=int(os.getenv("POKER44_AUTOSIMULATE_HANDS") or "3"),
                simulate_timeout_s=float(os.getenv("POKER44_AUTOSIMULATE_TIMEOUT_S") or "30.0"),
                min_simulate_interval_s=int(os.getenv("POKER44_AUTOSIMULATE_MIN_INTERVAL_S") or "15"),
            )
        else:
            bt.logging.info("ðŸ“ Using LOCAL generated data")
            labeled_chunks = generate_dataset_array(include_labels=True)
            self.provider = GeneratedDatasetProvider(labeled_chunks, shuffle=True, loop=True)

        self.poll_interval = self.settings.poll_interval_seconds
        self.prediction_buffer = {}
        self.label_buffer = {}

        # Optional P2P room directory announcements (MVP: shared-secret HMAC).
        self._start_p2p_announcer(provider_mode)

    def _ensure_room_code(self, *, platform_url: str, secret: str, validator_id: str) -> Optional[str]:
        if not platform_url or not secret:
            return None
        try:
            r = requests.post(
                f"{platform_url.rstrip('/')}/internal/rooms/ensure",
                headers={"x-eval-secret": secret, "content-type": "application/json"},
                json={"validatorId": validator_id},
                timeout=10.0,
            )
            r.raise_for_status()
            payload = r.json()
            if isinstance(payload, dict) and payload.get("success") and isinstance(payload.get("data"), dict):
                room_code = payload["data"].get("roomCode")
                return room_code if isinstance(room_code, str) and room_code else None
        except Exception as e:
            bt.logging.warning(f"P2P ensure room failed: {e}")
        return None

    def _maybe_start_room(self, *, platform_url: str, secret: str, room_code: Optional[str]) -> None:
        if not platform_url or not secret or not room_code:
            return
        try:
            r = requests.post(
                f"{platform_url.rstrip('/')}/internal/rooms/{room_code}/start",
                headers={"x-eval-secret": secret, "content-type": "application/json"},
                timeout=10.0,
            )
            r.raise_for_status()
            payload = r.json()
            if isinstance(payload, dict) and payload.get("success") and isinstance(payload.get("data"), dict):
                started = payload["data"].get("started")
                status = payload["data"].get("status")
                if started:
                    bt.logging.info(f"[p2p] started room game. room_code={room_code} status={status}")
        except Exception:
            # best-effort: often fails until enough players join
            return

    def _start_p2p_announcer(self, provider_mode: str) -> None:
        directory_url = (os.getenv("POKER44_DIRECTORY_URL") or "").strip().rstrip("/")
        if not directory_url:
            return

        directory_secret = (os.getenv("POKER44_DIRECTORY_SHARED_SECRET") or "").strip()
        if not directory_secret:
            bt.logging.warning("POKER44_DIRECTORY_SHARED_SECRET not set; cannot announce to directory.")
            return

        region = (os.getenv("POKER44_REGION") or "unknown").strip() or "unknown"
        capacity_tables = int(os.getenv("POKER44_CAPACITY_TABLES") or "1")
        version_hash = (os.getenv("POKER44_VERSION_HASH") or f"poker44-validator-{__version__}").strip()
        announce_interval_s = int(os.getenv("POKER44_ANNOUNCE_INTERVAL_S") or "10")

        validator_id = (os.getenv("POKER44_VALIDATOR_ID") or "").strip()
        if not validator_id:
            validator_id = self.wallet.hotkey.ss58_address

        # Friendly, non-unique name for UI/debug in the directory.
        validator_name = (os.getenv("POKER44_VALIDATOR_NAME") or "poker44-validator").strip() or "poker44-validator"

        platform_base_url = (os.getenv("POKER44_PLATFORM_BACKEND_URL") or "http://localhost:3001").strip()
        platform_public_url = (os.getenv("POKER44_PLATFORM_PUBLIC_URL") or platform_base_url).strip().rstrip("/")
        indexer_public_url = (os.getenv("POKER44_INDEXER_PUBLIC_URL") or "").strip().rstrip("/") or None
        internal_secret = (os.getenv("POKER44_INTERNAL_EVAL_SECRET") or "").strip()

        # Prefer a fixed room code if provided; otherwise ensure one exists via the local platform backend.
        room_code: Optional[str] = (os.getenv("POKER44_ROOM_CODE") or "").strip() or None
        if not room_code and provider_mode == "platform":
            room_code = self._ensure_room_code(
                platform_url=platform_base_url,
                secret=internal_secret,
                validator_id=validator_id,
            )

        client = RoomDirectoryClient(directory_url, directory_secret)

        def _loop() -> None:
            nonlocal room_code
            while True:
                # Ensure the advertised room exists and stays fresh.
                # Room JSON in Redis has a TTL, while player->room mappings are non-expiring.
                # Periodically re-ensuring lets the platform recreate rooms if they expired.
                if provider_mode == "platform":
                    ensured = self._ensure_room_code(
                        platform_url=platform_base_url,
                        secret=internal_secret,
                        validator_id=validator_id,
                    )
                    if ensured:
                        room_code = ensured

                # Best-effort: start the room game as the validator host once enough players joined.
                self._maybe_start_room(
                    platform_url=platform_base_url,
                    secret=internal_secret,
                    room_code=room_code,
                )

                try:
                    client.announce(
                        validator_id=validator_id,
                        validator_name=validator_name,
                        platform_url=platform_public_url,
                        indexer_url=indexer_public_url,
                        room_code=room_code,
                        region=region,
                        capacity_tables=capacity_tables,
                        version_hash=version_hash,
                    )
                    bt.logging.info(
                        f"[p2p] announced room. directory={directory_url} room_code={room_code!r} platform_url={platform_public_url}"
                    )
                except Exception as e:
                    bt.logging.warning(f"[p2p] announce failed: {e}")
                time.sleep(max(1, announce_interval_s))

        threading.Thread(target=_loop, daemon=True).start()

    def resolve_uid(self, hotkey: str) -> Optional[int]:
        try:
            return self.metagraph.hotkeys.index(hotkey)
        except ValueError:
            return None

    async def forward(self, synapse=None):  # type: ignore[override]
        return await forward_cycle(self)


if __name__ == "__main__":  # pragma: no cover - manual execution
    with Validator() as validator:
        while True:
            bt.logging.info(f"Validator running... {time.time()}")
            time.sleep(100)
