# The MIT License (MIT)
# Copyright Â© 2023 Yuma Rao

# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial portions of
# the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
# THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

"""Aceguard validator entrypoint wired into the base Bittensor neuron."""
# neuron/validator.py

from __future__ import annotations

import os
import random
import time
from typing import Optional, List, Dict, Any

import bittensor as bt
from dotenv import load_dotenv
import requests

from Aceguard import __version__
from Aceguard.base.validator import BaseValidatorNeuron
from Aceguard.utils.config import config
from Aceguard.core.hand_json import from_standard_json
from Aceguard.core.models import LabeledHandBatch
from Aceguard.validator.forward import forward as forward_cycle
from hands_generator.data_generator import generate_dataset_array

load_dotenv()
os.makedirs("./logs", exist_ok=True)
bt.logging.set_trace()
bt.logging(debug=True, trace=False, logging_dir="./logs", record_log=True)


class GeneratedDatasetProvider:
    """
    Local provider that sources hands from the in-memory dataset generated by
    hands_generator.data_generator.generate_dataset_array(include_labels=True).
    """

    def __init__(
        self,
        labeled_chunks: List[Dict[str, Any]],
        *,
        shuffle: bool = True,
        loop: bool = True,
    ) -> None:
        self.shuffle = shuffle
        self.loop = loop
        self._data = list(labeled_chunks)
        if self.shuffle:
            random.shuffle(self._data)
        self._idx = 0

    def fetch_hand_batch(
        self,
        *,
        limit: int = 10,
        include_integrity: bool = True,
    ) -> List[LabeledHandBatch]:
        if not self._data:
            return []

        batches: List[LabeledHandBatch] = []
        for _ in range(limit):
            if self._idx >= len(self._data):
                if not self.loop:
                    break
                self._idx = 0
                if self.shuffle:
                    random.shuffle(self._data)

            entry = self._data[self._idx]
            self._idx += 1

            hands_raw = entry.get("hands", [])
            is_bot = bool(entry.get("is_bot", False))
            hands = [from_standard_json(hand) for hand in hands_raw]
            batches.append(LabeledHandBatch(hands=hands, is_human=not is_bot))

        return batches


class PlatformBackendProvider:
    """
    Provider that pulls *fresh* labeled batches from the local validator poker backend.

    The backend must expose:
      GET /internal/eval/next?limit=10&requireMixed=true
    with header:
      x-eval-secret: <shared secret>

    Response format:
      { "success": true, "data": { "batches": [ { "is_human": bool, "hands": [dict, ...] }, ... ] } }
    """

    def __init__(
        self,
        base_url: str,
        secret: str,
        *,
        require_mixed: bool = True,
        timeout_s: float = 5.0,
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.secret = secret
        self.require_mixed = require_mixed
        self.timeout_s = timeout_s

    def fetch_hand_batch(
        self,
        *,
        limit: int = 10,
        include_integrity: bool = True,  # kept for provider compatibility
    ) -> List[LabeledHandBatch]:
        if not self.secret:
            bt.logging.warning("ACEGUARD_INTERNAL_EVAL_SECRET not set; cannot use platform provider.")
            return []

        try:
            r = requests.get(
                f"{self.base_url}/internal/eval/next",
                params={
                    "limit": int(limit),
                    "requireMixed": "true" if self.require_mixed else "false",
                },
                headers={"x-eval-secret": self.secret},
                timeout=self.timeout_s,
            )
            r.raise_for_status()
            data = r.json()
            if not isinstance(data, dict) or not data.get("success"):
                return []
            payload = data.get("data", {}) or {}
            raw_batches = payload.get("batches", [])
        except Exception as e:
            bt.logging.warning(f"Platform provider fetch failed: {e}")
            return []

        out: List[LabeledHandBatch] = []
        for b in raw_batches:
            try:
                is_human = bool(b.get("is_human", False))
                hands = b.get("hands", [])
                # Hands are already dict payloads (sanitized by the backend).
                out.append(LabeledHandBatch(hands=hands, is_human=is_human))
            except Exception:
                continue
        return out


class Validator(BaseValidatorNeuron):
    """Aceguard validator neuron wired into the BaseValidator scaffold."""

    def __init__(self):
        cfg = config(Validator)
        super().__init__(config=cfg)
        bt.logging.info(f"ðŸš€ Aceguard Validator v{__version__} started")

        self.forward_count = 0
        self.settings = cfg
        
        provider_mode = os.getenv("ACEGUARD_PROVIDER", "local_generated").strip().lower()
        if provider_mode == "platform":
            bt.logging.info("ðŸ”Œ Using PLATFORM backend provider (fresh hands)")
            self.provider = PlatformBackendProvider(
                base_url=os.getenv("ACEGUARD_PLATFORM_BACKEND_URL", "http://localhost:3001"),
                secret=os.getenv("ACEGUARD_INTERNAL_EVAL_SECRET", ""),
                require_mixed=os.getenv("ACEGUARD_REQUIRE_MIXED", "true").lower() != "false",
                timeout_s=float(os.getenv("ACEGUARD_PLATFORM_TIMEOUT_S", "5.0")),
            )
        else:
            bt.logging.info("ðŸ“ Using LOCAL generated data")
            labeled_chunks = generate_dataset_array(include_labels=True)
            self.provider = GeneratedDatasetProvider(labeled_chunks, shuffle=True, loop=True)

        self.poll_interval = self.settings.poll_interval_seconds
        self.prediction_buffer = {}
        self.label_buffer = {}

    def resolve_uid(self, hotkey: str) -> Optional[int]:
        try:
            return self.metagraph.hotkeys.index(hotkey)
        except ValueError:
            return None

    async def forward(self, synapse=None):  # type: ignore[override]
        return await forward_cycle(self)


if __name__ == "__main__":  # pragma: no cover - manual execution
    with Validator() as validator:
        while True:
            bt.logging.info(f"Validator running... {time.time()}")
            time.sleep(100)
